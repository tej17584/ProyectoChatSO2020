// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mensaje.proto

#ifndef PROTOBUF_mensaje_2eproto__INCLUDED
#define PROTOBUF_mensaje_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace chat {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_mensaje_2eproto();
void protobuf_AssignDesc_mensaje_2eproto();
void protobuf_ShutdownFile_mensaje_2eproto();

class BroadcastMessage;
class BroadcastRequest;
class BroadcastResponse;
class ChangeStatusRequest;
class ChangeStatusResponse;
class ClientMessage;
class ConnectedUser;
class ConnectedUserResponse;
class DirectMessage;
class DirectMessageRequest;
class DirectMessageResponse;
class ErrorResponse;
class MyInfoAcknowledge;
class MyInfoResponse;
class MyInfoSynchronize;
class ServerMessage;
class connectedUserRequest;

// ===================================================================

class MyInfoSynchronize : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.MyInfoSynchronize) */ {
 public:
  MyInfoSynchronize();
  virtual ~MyInfoSynchronize();

  MyInfoSynchronize(const MyInfoSynchronize& from);

  inline MyInfoSynchronize& operator=(const MyInfoSynchronize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MyInfoSynchronize& default_instance();

  void Swap(MyInfoSynchronize* other);

  // implements Message ----------------------------------------------

  inline MyInfoSynchronize* New() const { return New(NULL); }

  MyInfoSynchronize* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MyInfoSynchronize& from);
  void MergeFrom(const MyInfoSynchronize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MyInfoSynchronize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string ip = 2;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:chat.MyInfoSynchronize)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  friend void  protobuf_AddDesc_mensaje_2eproto();
  friend void protobuf_AssignDesc_mensaje_2eproto();
  friend void protobuf_ShutdownFile_mensaje_2eproto();

  void InitAsDefaultInstance();
  static MyInfoSynchronize* default_instance_;
};
// -------------------------------------------------------------------

class MyInfoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.MyInfoResponse) */ {
 public:
  MyInfoResponse();
  virtual ~MyInfoResponse();

  MyInfoResponse(const MyInfoResponse& from);

  inline MyInfoResponse& operator=(const MyInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MyInfoResponse& default_instance();

  void Swap(MyInfoResponse* other);

  // implements Message ----------------------------------------------

  inline MyInfoResponse* New() const { return New(NULL); }

  MyInfoResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MyInfoResponse& from);
  void MergeFrom(const MyInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MyInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userId = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:chat.MyInfoResponse)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 userid_;
  friend void  protobuf_AddDesc_mensaje_2eproto();
  friend void protobuf_AssignDesc_mensaje_2eproto();
  friend void protobuf_ShutdownFile_mensaje_2eproto();

  void InitAsDefaultInstance();
  static MyInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class MyInfoAcknowledge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.MyInfoAcknowledge) */ {
 public:
  MyInfoAcknowledge();
  virtual ~MyInfoAcknowledge();

  MyInfoAcknowledge(const MyInfoAcknowledge& from);

  inline MyInfoAcknowledge& operator=(const MyInfoAcknowledge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MyInfoAcknowledge& default_instance();

  void Swap(MyInfoAcknowledge* other);

  // implements Message ----------------------------------------------

  inline MyInfoAcknowledge* New() const { return New(NULL); }

  MyInfoAcknowledge* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MyInfoAcknowledge& from);
  void MergeFrom(const MyInfoAcknowledge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MyInfoAcknowledge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userId = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:chat.MyInfoAcknowledge)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 userid_;
  friend void  protobuf_AddDesc_mensaje_2eproto();
  friend void protobuf_AssignDesc_mensaje_2eproto();
  friend void protobuf_ShutdownFile_mensaje_2eproto();

  void InitAsDefaultInstance();
  static MyInfoAcknowledge* default_instance_;
};
// -------------------------------------------------------------------

class connectedUserRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.connectedUserRequest) */ {
 public:
  connectedUserRequest();
  virtual ~connectedUserRequest();

  connectedUserRequest(const connectedUserRequest& from);

  inline connectedUserRequest& operator=(const connectedUserRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const connectedUserRequest& default_instance();

  void Swap(connectedUserRequest* other);

  // implements Message ----------------------------------------------

  inline connectedUserRequest* New() const { return New(NULL); }

  connectedUserRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const connectedUserRequest& from);
  void MergeFrom(const connectedUserRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(connectedUserRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 userId = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // optional string username = 2;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:chat.connectedUserRequest)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_username();
  inline void clear_has_username();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::int32 userid_;
  friend void  protobuf_AddDesc_mensaje_2eproto();
  friend void protobuf_AssignDesc_mensaje_2eproto();
  friend void protobuf_ShutdownFile_mensaje_2eproto();

  void InitAsDefaultInstance();
  static connectedUserRequest* default_instance_;
};
// -------------------------------------------------------------------

class ConnectedUser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ConnectedUser) */ {
 public:
  ConnectedUser();
  virtual ~ConnectedUser();

  ConnectedUser(const ConnectedUser& from);

  inline ConnectedUser& operator=(const ConnectedUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectedUser& default_instance();

  void Swap(ConnectedUser* other);

  // implements Message ----------------------------------------------

  inline ConnectedUser* New() const { return New(NULL); }

  ConnectedUser* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectedUser& from);
  void MergeFrom(const ConnectedUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectedUser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // optional int32 userId = 3;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 3;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // optional string ip = 4;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 4;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:chat.ConnectedUser)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::int32 userid_;
  friend void  protobuf_AddDesc_mensaje_2eproto();
  friend void protobuf_AssignDesc_mensaje_2eproto();
  friend void protobuf_ShutdownFile_mensaje_2eproto();

  void InitAsDefaultInstance();
  static ConnectedUser* default_instance_;
};
// -------------------------------------------------------------------

class ConnectedUserResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ConnectedUserResponse) */ {
 public:
  ConnectedUserResponse();
  virtual ~ConnectedUserResponse();

  ConnectedUserResponse(const ConnectedUserResponse& from);

  inline ConnectedUserResponse& operator=(const ConnectedUserResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectedUserResponse& default_instance();

  void Swap(ConnectedUserResponse* other);

  // implements Message ----------------------------------------------

  inline ConnectedUserResponse* New() const { return New(NULL); }

  ConnectedUserResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectedUserResponse& from);
  void MergeFrom(const ConnectedUserResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectedUserResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .chat.ConnectedUser connectedUsers = 1;
  int connectedusers_size() const;
  void clear_connectedusers();
  static const int kConnectedUsersFieldNumber = 1;
  const ::chat::ConnectedUser& connectedusers(int index) const;
  ::chat::ConnectedUser* mutable_connectedusers(int index);
  ::chat::ConnectedUser* add_connectedusers();
  ::google::protobuf::RepeatedPtrField< ::chat::ConnectedUser >*
      mutable_connectedusers();
  const ::google::protobuf::RepeatedPtrField< ::chat::ConnectedUser >&
      connectedusers() const;

  // @@protoc_insertion_point(class_scope:chat.ConnectedUserResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::chat::ConnectedUser > connectedusers_;
  friend void  protobuf_AddDesc_mensaje_2eproto();
  friend void protobuf_AssignDesc_mensaje_2eproto();
  friend void protobuf_ShutdownFile_mensaje_2eproto();

  void InitAsDefaultInstance();
  static ConnectedUserResponse* default_instance_;
};
// -------------------------------------------------------------------

class ChangeStatusRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ChangeStatusRequest) */ {
 public:
  ChangeStatusRequest();
  virtual ~ChangeStatusRequest();

  ChangeStatusRequest(const ChangeStatusRequest& from);

  inline ChangeStatusRequest& operator=(const ChangeStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeStatusRequest& default_instance();

  void Swap(ChangeStatusRequest* other);

  // implements Message ----------------------------------------------

  inline ChangeStatusRequest* New() const { return New(NULL); }

  ChangeStatusRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeStatusRequest& from);
  void MergeFrom(const ChangeStatusRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChangeStatusRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:chat.ChangeStatusRequest)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  friend void  protobuf_AddDesc_mensaje_2eproto();
  friend void protobuf_AssignDesc_mensaje_2eproto();
  friend void protobuf_ShutdownFile_mensaje_2eproto();

  void InitAsDefaultInstance();
  static ChangeStatusRequest* default_instance_;
};
// -------------------------------------------------------------------

class ChangeStatusResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ChangeStatusResponse) */ {
 public:
  ChangeStatusResponse();
  virtual ~ChangeStatusResponse();

  ChangeStatusResponse(const ChangeStatusResponse& from);

  inline ChangeStatusResponse& operator=(const ChangeStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeStatusResponse& default_instance();

  void Swap(ChangeStatusResponse* other);

  // implements Message ----------------------------------------------

  inline ChangeStatusResponse* New() const { return New(NULL); }

  ChangeStatusResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeStatusResponse& from);
  void MergeFrom(const ChangeStatusResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChangeStatusResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 userId = 1;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // required string status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:chat.ChangeStatusResponse)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_status();
  inline void clear_has_status();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::int32 userid_;
  friend void  protobuf_AddDesc_mensaje_2eproto();
  friend void protobuf_AssignDesc_mensaje_2eproto();
  friend void protobuf_ShutdownFile_mensaje_2eproto();

  void InitAsDefaultInstance();
  static ChangeStatusResponse* default_instance_;
};
// -------------------------------------------------------------------

class BroadcastRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.BroadcastRequest) */ {
 public:
  BroadcastRequest();
  virtual ~BroadcastRequest();

  BroadcastRequest(const BroadcastRequest& from);

  inline BroadcastRequest& operator=(const BroadcastRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BroadcastRequest& default_instance();

  void Swap(BroadcastRequest* other);

  // implements Message ----------------------------------------------

  inline BroadcastRequest* New() const { return New(NULL); }

  BroadcastRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BroadcastRequest& from);
  void MergeFrom(const BroadcastRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BroadcastRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:chat.BroadcastRequest)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  friend void  protobuf_AddDesc_mensaje_2eproto();
  friend void protobuf_AssignDesc_mensaje_2eproto();
  friend void protobuf_ShutdownFile_mensaje_2eproto();

  void InitAsDefaultInstance();
  static BroadcastRequest* default_instance_;
};
// -------------------------------------------------------------------

class BroadcastResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.BroadcastResponse) */ {
 public:
  BroadcastResponse();
  virtual ~BroadcastResponse();

  BroadcastResponse(const BroadcastResponse& from);

  inline BroadcastResponse& operator=(const BroadcastResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BroadcastResponse& default_instance();

  void Swap(BroadcastResponse* other);

  // implements Message ----------------------------------------------

  inline BroadcastResponse* New() const { return New(NULL); }

  BroadcastResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BroadcastResponse& from);
  void MergeFrom(const BroadcastResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BroadcastResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string messageStatus = 1;
  bool has_messagestatus() const;
  void clear_messagestatus();
  static const int kMessageStatusFieldNumber = 1;
  const ::std::string& messagestatus() const;
  void set_messagestatus(const ::std::string& value);
  void set_messagestatus(const char* value);
  void set_messagestatus(const char* value, size_t size);
  ::std::string* mutable_messagestatus();
  ::std::string* release_messagestatus();
  void set_allocated_messagestatus(::std::string* messagestatus);

  // @@protoc_insertion_point(class_scope:chat.BroadcastResponse)
 private:
  inline void set_has_messagestatus();
  inline void clear_has_messagestatus();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr messagestatus_;
  friend void  protobuf_AddDesc_mensaje_2eproto();
  friend void protobuf_AssignDesc_mensaje_2eproto();
  friend void protobuf_ShutdownFile_mensaje_2eproto();

  void InitAsDefaultInstance();
  static BroadcastResponse* default_instance_;
};
// -------------------------------------------------------------------

class BroadcastMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.BroadcastMessage) */ {
 public:
  BroadcastMessage();
  virtual ~BroadcastMessage();

  BroadcastMessage(const BroadcastMessage& from);

  inline BroadcastMessage& operator=(const BroadcastMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BroadcastMessage& default_instance();

  void Swap(BroadcastMessage* other);

  // implements Message ----------------------------------------------

  inline BroadcastMessage* New() const { return New(NULL); }

  BroadcastMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BroadcastMessage& from);
  void MergeFrom(const BroadcastMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BroadcastMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // required int32 userId = 2;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 2;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:chat.BroadcastMessage)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_userid();
  inline void clear_has_userid();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::int32 userid_;
  friend void  protobuf_AddDesc_mensaje_2eproto();
  friend void protobuf_AssignDesc_mensaje_2eproto();
  friend void protobuf_ShutdownFile_mensaje_2eproto();

  void InitAsDefaultInstance();
  static BroadcastMessage* default_instance_;
};
// -------------------------------------------------------------------

class DirectMessageRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.DirectMessageRequest) */ {
 public:
  DirectMessageRequest();
  virtual ~DirectMessageRequest();

  DirectMessageRequest(const DirectMessageRequest& from);

  inline DirectMessageRequest& operator=(const DirectMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectMessageRequest& default_instance();

  void Swap(DirectMessageRequest* other);

  // implements Message ----------------------------------------------

  inline DirectMessageRequest* New() const { return New(NULL); }

  DirectMessageRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DirectMessageRequest& from);
  void MergeFrom(const DirectMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectMessageRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional int32 userId = 2;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 2;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // optional string username = 3;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:chat.DirectMessageRequest)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_username();
  inline void clear_has_username();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::int32 userid_;
  friend void  protobuf_AddDesc_mensaje_2eproto();
  friend void protobuf_AssignDesc_mensaje_2eproto();
  friend void protobuf_ShutdownFile_mensaje_2eproto();

  void InitAsDefaultInstance();
  static DirectMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class DirectMessageResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.DirectMessageResponse) */ {
 public:
  DirectMessageResponse();
  virtual ~DirectMessageResponse();

  DirectMessageResponse(const DirectMessageResponse& from);

  inline DirectMessageResponse& operator=(const DirectMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectMessageResponse& default_instance();

  void Swap(DirectMessageResponse* other);

  // implements Message ----------------------------------------------

  inline DirectMessageResponse* New() const { return New(NULL); }

  DirectMessageResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DirectMessageResponse& from);
  void MergeFrom(const DirectMessageResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectMessageResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string messageStatus = 1;
  bool has_messagestatus() const;
  void clear_messagestatus();
  static const int kMessageStatusFieldNumber = 1;
  const ::std::string& messagestatus() const;
  void set_messagestatus(const ::std::string& value);
  void set_messagestatus(const char* value);
  void set_messagestatus(const char* value, size_t size);
  ::std::string* mutable_messagestatus();
  ::std::string* release_messagestatus();
  void set_allocated_messagestatus(::std::string* messagestatus);

  // @@protoc_insertion_point(class_scope:chat.DirectMessageResponse)
 private:
  inline void set_has_messagestatus();
  inline void clear_has_messagestatus();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr messagestatus_;
  friend void  protobuf_AddDesc_mensaje_2eproto();
  friend void protobuf_AssignDesc_mensaje_2eproto();
  friend void protobuf_ShutdownFile_mensaje_2eproto();

  void InitAsDefaultInstance();
  static DirectMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class DirectMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.DirectMessage) */ {
 public:
  DirectMessage();
  virtual ~DirectMessage();

  DirectMessage(const DirectMessage& from);

  inline DirectMessage& operator=(const DirectMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectMessage& default_instance();

  void Swap(DirectMessage* other);

  // implements Message ----------------------------------------------

  inline DirectMessage* New() const { return New(NULL); }

  DirectMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DirectMessage& from);
  void MergeFrom(const DirectMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DirectMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // required int32 userId = 2;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 2;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:chat.DirectMessage)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_userid();
  inline void clear_has_userid();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::int32 userid_;
  friend void  protobuf_AddDesc_mensaje_2eproto();
  friend void protobuf_AssignDesc_mensaje_2eproto();
  friend void protobuf_ShutdownFile_mensaje_2eproto();

  void InitAsDefaultInstance();
  static DirectMessage* default_instance_;
};
// -------------------------------------------------------------------

class ErrorResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ErrorResponse) */ {
 public:
  ErrorResponse();
  virtual ~ErrorResponse();

  ErrorResponse(const ErrorResponse& from);

  inline ErrorResponse& operator=(const ErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorResponse& default_instance();

  void Swap(ErrorResponse* other);

  // implements Message ----------------------------------------------

  inline ErrorResponse* New() const { return New(NULL); }

  ErrorResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ErrorResponse& from);
  void MergeFrom(const ErrorResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ErrorResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string errorMessage = 1;
  bool has_errormessage() const;
  void clear_errormessage();
  static const int kErrorMessageFieldNumber = 1;
  const ::std::string& errormessage() const;
  void set_errormessage(const ::std::string& value);
  void set_errormessage(const char* value);
  void set_errormessage(const char* value, size_t size);
  ::std::string* mutable_errormessage();
  ::std::string* release_errormessage();
  void set_allocated_errormessage(::std::string* errormessage);

  // @@protoc_insertion_point(class_scope:chat.ErrorResponse)
 private:
  inline void set_has_errormessage();
  inline void clear_has_errormessage();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr errormessage_;
  friend void  protobuf_AddDesc_mensaje_2eproto();
  friend void protobuf_AssignDesc_mensaje_2eproto();
  friend void protobuf_ShutdownFile_mensaje_2eproto();

  void InitAsDefaultInstance();
  static ErrorResponse* default_instance_;
};
// -------------------------------------------------------------------

class ClientMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ClientMessage) */ {
 public:
  ClientMessage();
  virtual ~ClientMessage();

  ClientMessage(const ClientMessage& from);

  inline ClientMessage& operator=(const ClientMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage& default_instance();

  void Swap(ClientMessage* other);

  // implements Message ----------------------------------------------

  inline ClientMessage* New() const { return New(NULL); }

  ClientMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMessage& from);
  void MergeFrom(const ClientMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 option = 1;
  bool has_option() const;
  void clear_option();
  static const int kOptionFieldNumber = 1;
  ::google::protobuf::int32 option() const;
  void set_option(::google::protobuf::int32 value);

  // optional int32 userId = 2;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 2;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // optional .chat.MyInfoSynchronize synchronize = 3;
  bool has_synchronize() const;
  void clear_synchronize();
  static const int kSynchronizeFieldNumber = 3;
  const ::chat::MyInfoSynchronize& synchronize() const;
  ::chat::MyInfoSynchronize* mutable_synchronize();
  ::chat::MyInfoSynchronize* release_synchronize();
  void set_allocated_synchronize(::chat::MyInfoSynchronize* synchronize);

  // optional .chat.connectedUserRequest connectedUsers = 4;
  bool has_connectedusers() const;
  void clear_connectedusers();
  static const int kConnectedUsersFieldNumber = 4;
  const ::chat::connectedUserRequest& connectedusers() const;
  ::chat::connectedUserRequest* mutable_connectedusers();
  ::chat::connectedUserRequest* release_connectedusers();
  void set_allocated_connectedusers(::chat::connectedUserRequest* connectedusers);

  // optional .chat.ChangeStatusRequest changeStatus = 5;
  bool has_changestatus() const;
  void clear_changestatus();
  static const int kChangeStatusFieldNumber = 5;
  const ::chat::ChangeStatusRequest& changestatus() const;
  ::chat::ChangeStatusRequest* mutable_changestatus();
  ::chat::ChangeStatusRequest* release_changestatus();
  void set_allocated_changestatus(::chat::ChangeStatusRequest* changestatus);

  // optional .chat.BroadcastRequest broadcast = 6;
  bool has_broadcast() const;
  void clear_broadcast();
  static const int kBroadcastFieldNumber = 6;
  const ::chat::BroadcastRequest& broadcast() const;
  ::chat::BroadcastRequest* mutable_broadcast();
  ::chat::BroadcastRequest* release_broadcast();
  void set_allocated_broadcast(::chat::BroadcastRequest* broadcast);

  // optional .chat.DirectMessageRequest directMessage = 7;
  bool has_directmessage() const;
  void clear_directmessage();
  static const int kDirectMessageFieldNumber = 7;
  const ::chat::DirectMessageRequest& directmessage() const;
  ::chat::DirectMessageRequest* mutable_directmessage();
  ::chat::DirectMessageRequest* release_directmessage();
  void set_allocated_directmessage(::chat::DirectMessageRequest* directmessage);

  // optional .chat.MyInfoAcknowledge acknowledge = 8;
  bool has_acknowledge() const;
  void clear_acknowledge();
  static const int kAcknowledgeFieldNumber = 8;
  const ::chat::MyInfoAcknowledge& acknowledge() const;
  ::chat::MyInfoAcknowledge* mutable_acknowledge();
  ::chat::MyInfoAcknowledge* release_acknowledge();
  void set_allocated_acknowledge(::chat::MyInfoAcknowledge* acknowledge);

  // @@protoc_insertion_point(class_scope:chat.ClientMessage)
 private:
  inline void set_has_option();
  inline void clear_has_option();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_synchronize();
  inline void clear_has_synchronize();
  inline void set_has_connectedusers();
  inline void clear_has_connectedusers();
  inline void set_has_changestatus();
  inline void clear_has_changestatus();
  inline void set_has_broadcast();
  inline void clear_has_broadcast();
  inline void set_has_directmessage();
  inline void clear_has_directmessage();
  inline void set_has_acknowledge();
  inline void clear_has_acknowledge();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 option_;
  ::google::protobuf::int32 userid_;
  ::chat::MyInfoSynchronize* synchronize_;
  ::chat::connectedUserRequest* connectedusers_;
  ::chat::ChangeStatusRequest* changestatus_;
  ::chat::BroadcastRequest* broadcast_;
  ::chat::DirectMessageRequest* directmessage_;
  ::chat::MyInfoAcknowledge* acknowledge_;
  friend void  protobuf_AddDesc_mensaje_2eproto();
  friend void protobuf_AssignDesc_mensaje_2eproto();
  friend void protobuf_ShutdownFile_mensaje_2eproto();

  void InitAsDefaultInstance();
  static ClientMessage* default_instance_;
};
// -------------------------------------------------------------------

class ServerMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chat.ServerMessage) */ {
 public:
  ServerMessage();
  virtual ~ServerMessage();

  ServerMessage(const ServerMessage& from);

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMessage& default_instance();

  void Swap(ServerMessage* other);

  // implements Message ----------------------------------------------

  inline ServerMessage* New() const { return New(NULL); }

  ServerMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerMessage& from);
  void MergeFrom(const ServerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 option = 1;
  bool has_option() const;
  void clear_option();
  static const int kOptionFieldNumber = 1;
  ::google::protobuf::int32 option() const;
  void set_option(::google::protobuf::int32 value);

  // optional .chat.BroadcastMessage broadcast = 2;
  bool has_broadcast() const;
  void clear_broadcast();
  static const int kBroadcastFieldNumber = 2;
  const ::chat::BroadcastMessage& broadcast() const;
  ::chat::BroadcastMessage* mutable_broadcast();
  ::chat::BroadcastMessage* release_broadcast();
  void set_allocated_broadcast(::chat::BroadcastMessage* broadcast);

  // optional .chat.DirectMessage message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::chat::DirectMessage& message() const;
  ::chat::DirectMessage* mutable_message();
  ::chat::DirectMessage* release_message();
  void set_allocated_message(::chat::DirectMessage* message);

  // optional .chat.ErrorResponse error = 4;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 4;
  const ::chat::ErrorResponse& error() const;
  ::chat::ErrorResponse* mutable_error();
  ::chat::ErrorResponse* release_error();
  void set_allocated_error(::chat::ErrorResponse* error);

  // optional .chat.MyInfoResponse myInfoResponse = 5;
  bool has_myinforesponse() const;
  void clear_myinforesponse();
  static const int kMyInfoResponseFieldNumber = 5;
  const ::chat::MyInfoResponse& myinforesponse() const;
  ::chat::MyInfoResponse* mutable_myinforesponse();
  ::chat::MyInfoResponse* release_myinforesponse();
  void set_allocated_myinforesponse(::chat::MyInfoResponse* myinforesponse);

  // optional .chat.ConnectedUserResponse connectedUserResponse = 6;
  bool has_connecteduserresponse() const;
  void clear_connecteduserresponse();
  static const int kConnectedUserResponseFieldNumber = 6;
  const ::chat::ConnectedUserResponse& connecteduserresponse() const;
  ::chat::ConnectedUserResponse* mutable_connecteduserresponse();
  ::chat::ConnectedUserResponse* release_connecteduserresponse();
  void set_allocated_connecteduserresponse(::chat::ConnectedUserResponse* connecteduserresponse);

  // optional .chat.ChangeStatusResponse changeStatusResponse = 7;
  bool has_changestatusresponse() const;
  void clear_changestatusresponse();
  static const int kChangeStatusResponseFieldNumber = 7;
  const ::chat::ChangeStatusResponse& changestatusresponse() const;
  ::chat::ChangeStatusResponse* mutable_changestatusresponse();
  ::chat::ChangeStatusResponse* release_changestatusresponse();
  void set_allocated_changestatusresponse(::chat::ChangeStatusResponse* changestatusresponse);

  // optional .chat.BroadcastResponse broadcastResponse = 8;
  bool has_broadcastresponse() const;
  void clear_broadcastresponse();
  static const int kBroadcastResponseFieldNumber = 8;
  const ::chat::BroadcastResponse& broadcastresponse() const;
  ::chat::BroadcastResponse* mutable_broadcastresponse();
  ::chat::BroadcastResponse* release_broadcastresponse();
  void set_allocated_broadcastresponse(::chat::BroadcastResponse* broadcastresponse);

  // optional .chat.DirectMessageResponse directMessageResponse = 9;
  bool has_directmessageresponse() const;
  void clear_directmessageresponse();
  static const int kDirectMessageResponseFieldNumber = 9;
  const ::chat::DirectMessageResponse& directmessageresponse() const;
  ::chat::DirectMessageResponse* mutable_directmessageresponse();
  ::chat::DirectMessageResponse* release_directmessageresponse();
  void set_allocated_directmessageresponse(::chat::DirectMessageResponse* directmessageresponse);

  // @@protoc_insertion_point(class_scope:chat.ServerMessage)
 private:
  inline void set_has_option();
  inline void clear_has_option();
  inline void set_has_broadcast();
  inline void clear_has_broadcast();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_myinforesponse();
  inline void clear_has_myinforesponse();
  inline void set_has_connecteduserresponse();
  inline void clear_has_connecteduserresponse();
  inline void set_has_changestatusresponse();
  inline void clear_has_changestatusresponse();
  inline void set_has_broadcastresponse();
  inline void clear_has_broadcastresponse();
  inline void set_has_directmessageresponse();
  inline void clear_has_directmessageresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::chat::BroadcastMessage* broadcast_;
  ::chat::DirectMessage* message_;
  ::chat::ErrorResponse* error_;
  ::chat::MyInfoResponse* myinforesponse_;
  ::chat::ConnectedUserResponse* connecteduserresponse_;
  ::chat::ChangeStatusResponse* changestatusresponse_;
  ::chat::BroadcastResponse* broadcastresponse_;
  ::chat::DirectMessageResponse* directmessageresponse_;
  ::google::protobuf::int32 option_;
  friend void  protobuf_AddDesc_mensaje_2eproto();
  friend void protobuf_AssignDesc_mensaje_2eproto();
  friend void protobuf_ShutdownFile_mensaje_2eproto();

  void InitAsDefaultInstance();
  static ServerMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// MyInfoSynchronize

// required string username = 1;
inline bool MyInfoSynchronize::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MyInfoSynchronize::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MyInfoSynchronize::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MyInfoSynchronize::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& MyInfoSynchronize::username() const {
  // @@protoc_insertion_point(field_get:chat.MyInfoSynchronize.username)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MyInfoSynchronize::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.MyInfoSynchronize.username)
}
inline void MyInfoSynchronize::set_username(const char* value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.MyInfoSynchronize.username)
}
inline void MyInfoSynchronize::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.MyInfoSynchronize.username)
}
inline ::std::string* MyInfoSynchronize::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:chat.MyInfoSynchronize.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MyInfoSynchronize::release_username() {
  // @@protoc_insertion_point(field_release:chat.MyInfoSynchronize.username)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MyInfoSynchronize::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.MyInfoSynchronize.username)
}

// optional string ip = 2;
inline bool MyInfoSynchronize::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MyInfoSynchronize::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MyInfoSynchronize::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MyInfoSynchronize::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& MyInfoSynchronize::ip() const {
  // @@protoc_insertion_point(field_get:chat.MyInfoSynchronize.ip)
  return ip_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MyInfoSynchronize::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.MyInfoSynchronize.ip)
}
inline void MyInfoSynchronize::set_ip(const char* value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.MyInfoSynchronize.ip)
}
inline void MyInfoSynchronize::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.MyInfoSynchronize.ip)
}
inline ::std::string* MyInfoSynchronize::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:chat.MyInfoSynchronize.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MyInfoSynchronize::release_ip() {
  // @@protoc_insertion_point(field_release:chat.MyInfoSynchronize.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MyInfoSynchronize::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:chat.MyInfoSynchronize.ip)
}

// -------------------------------------------------------------------

// MyInfoResponse

// required int32 userId = 1;
inline bool MyInfoResponse::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MyInfoResponse::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MyInfoResponse::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MyInfoResponse::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 MyInfoResponse::userid() const {
  // @@protoc_insertion_point(field_get:chat.MyInfoResponse.userId)
  return userid_;
}
inline void MyInfoResponse::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.MyInfoResponse.userId)
}

// -------------------------------------------------------------------

// MyInfoAcknowledge

// required int32 userId = 1;
inline bool MyInfoAcknowledge::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MyInfoAcknowledge::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MyInfoAcknowledge::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MyInfoAcknowledge::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 MyInfoAcknowledge::userid() const {
  // @@protoc_insertion_point(field_get:chat.MyInfoAcknowledge.userId)
  return userid_;
}
inline void MyInfoAcknowledge::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.MyInfoAcknowledge.userId)
}

// -------------------------------------------------------------------

// connectedUserRequest

// optional int32 userId = 1;
inline bool connectedUserRequest::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void connectedUserRequest::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void connectedUserRequest::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void connectedUserRequest::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 connectedUserRequest::userid() const {
  // @@protoc_insertion_point(field_get:chat.connectedUserRequest.userId)
  return userid_;
}
inline void connectedUserRequest::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.connectedUserRequest.userId)
}

// optional string username = 2;
inline bool connectedUserRequest::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void connectedUserRequest::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void connectedUserRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void connectedUserRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& connectedUserRequest::username() const {
  // @@protoc_insertion_point(field_get:chat.connectedUserRequest.username)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void connectedUserRequest::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.connectedUserRequest.username)
}
inline void connectedUserRequest::set_username(const char* value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.connectedUserRequest.username)
}
inline void connectedUserRequest::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.connectedUserRequest.username)
}
inline ::std::string* connectedUserRequest::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:chat.connectedUserRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* connectedUserRequest::release_username() {
  // @@protoc_insertion_point(field_release:chat.connectedUserRequest.username)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void connectedUserRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.connectedUserRequest.username)
}

// -------------------------------------------------------------------

// ConnectedUser

// required string username = 1;
inline bool ConnectedUser::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectedUser::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectedUser::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectedUser::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& ConnectedUser::username() const {
  // @@protoc_insertion_point(field_get:chat.ConnectedUser.username)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectedUser::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.ConnectedUser.username)
}
inline void ConnectedUser::set_username(const char* value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.ConnectedUser.username)
}
inline void ConnectedUser::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.ConnectedUser.username)
}
inline ::std::string* ConnectedUser::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:chat.ConnectedUser.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectedUser::release_username() {
  // @@protoc_insertion_point(field_release:chat.ConnectedUser.username)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectedUser::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.ConnectedUser.username)
}

// optional string status = 2;
inline bool ConnectedUser::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectedUser::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectedUser::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectedUser::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_status();
}
inline const ::std::string& ConnectedUser::status() const {
  // @@protoc_insertion_point(field_get:chat.ConnectedUser.status)
  return status_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectedUser::set_status(const ::std::string& value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.ConnectedUser.status)
}
inline void ConnectedUser::set_status(const char* value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.ConnectedUser.status)
}
inline void ConnectedUser::set_status(const char* value, size_t size) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.ConnectedUser.status)
}
inline ::std::string* ConnectedUser::mutable_status() {
  set_has_status();
  // @@protoc_insertion_point(field_mutable:chat.ConnectedUser.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectedUser::release_status() {
  // @@protoc_insertion_point(field_release:chat.ConnectedUser.status)
  clear_has_status();
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectedUser::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    set_has_status();
  } else {
    clear_has_status();
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:chat.ConnectedUser.status)
}

// optional int32 userId = 3;
inline bool ConnectedUser::has_userid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectedUser::set_has_userid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectedUser::clear_has_userid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectedUser::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 ConnectedUser::userid() const {
  // @@protoc_insertion_point(field_get:chat.ConnectedUser.userId)
  return userid_;
}
inline void ConnectedUser::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.ConnectedUser.userId)
}

// optional string ip = 4;
inline bool ConnectedUser::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnectedUser::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnectedUser::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnectedUser::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& ConnectedUser::ip() const {
  // @@protoc_insertion_point(field_get:chat.ConnectedUser.ip)
  return ip_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectedUser::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.ConnectedUser.ip)
}
inline void ConnectedUser::set_ip(const char* value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.ConnectedUser.ip)
}
inline void ConnectedUser::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.ConnectedUser.ip)
}
inline ::std::string* ConnectedUser::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:chat.ConnectedUser.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectedUser::release_ip() {
  // @@protoc_insertion_point(field_release:chat.ConnectedUser.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectedUser::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:chat.ConnectedUser.ip)
}

// -------------------------------------------------------------------

// ConnectedUserResponse

// repeated .chat.ConnectedUser connectedUsers = 1;
inline int ConnectedUserResponse::connectedusers_size() const {
  return connectedusers_.size();
}
inline void ConnectedUserResponse::clear_connectedusers() {
  connectedusers_.Clear();
}
inline const ::chat::ConnectedUser& ConnectedUserResponse::connectedusers(int index) const {
  // @@protoc_insertion_point(field_get:chat.ConnectedUserResponse.connectedUsers)
  return connectedusers_.Get(index);
}
inline ::chat::ConnectedUser* ConnectedUserResponse::mutable_connectedusers(int index) {
  // @@protoc_insertion_point(field_mutable:chat.ConnectedUserResponse.connectedUsers)
  return connectedusers_.Mutable(index);
}
inline ::chat::ConnectedUser* ConnectedUserResponse::add_connectedusers() {
  // @@protoc_insertion_point(field_add:chat.ConnectedUserResponse.connectedUsers)
  return connectedusers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chat::ConnectedUser >*
ConnectedUserResponse::mutable_connectedusers() {
  // @@protoc_insertion_point(field_mutable_list:chat.ConnectedUserResponse.connectedUsers)
  return &connectedusers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chat::ConnectedUser >&
ConnectedUserResponse::connectedusers() const {
  // @@protoc_insertion_point(field_list:chat.ConnectedUserResponse.connectedUsers)
  return connectedusers_;
}

// -------------------------------------------------------------------

// ChangeStatusRequest

// required string status = 1;
inline bool ChangeStatusRequest::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeStatusRequest::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeStatusRequest::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeStatusRequest::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_status();
}
inline const ::std::string& ChangeStatusRequest::status() const {
  // @@protoc_insertion_point(field_get:chat.ChangeStatusRequest.status)
  return status_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeStatusRequest::set_status(const ::std::string& value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.ChangeStatusRequest.status)
}
inline void ChangeStatusRequest::set_status(const char* value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.ChangeStatusRequest.status)
}
inline void ChangeStatusRequest::set_status(const char* value, size_t size) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.ChangeStatusRequest.status)
}
inline ::std::string* ChangeStatusRequest::mutable_status() {
  set_has_status();
  // @@protoc_insertion_point(field_mutable:chat.ChangeStatusRequest.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangeStatusRequest::release_status() {
  // @@protoc_insertion_point(field_release:chat.ChangeStatusRequest.status)
  clear_has_status();
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeStatusRequest::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    set_has_status();
  } else {
    clear_has_status();
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:chat.ChangeStatusRequest.status)
}

// -------------------------------------------------------------------

// ChangeStatusResponse

// required int32 userId = 1;
inline bool ChangeStatusResponse::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeStatusResponse::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeStatusResponse::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeStatusResponse::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 ChangeStatusResponse::userid() const {
  // @@protoc_insertion_point(field_get:chat.ChangeStatusResponse.userId)
  return userid_;
}
inline void ChangeStatusResponse::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.ChangeStatusResponse.userId)
}

// required string status = 2;
inline bool ChangeStatusResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeStatusResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeStatusResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeStatusResponse::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_status();
}
inline const ::std::string& ChangeStatusResponse::status() const {
  // @@protoc_insertion_point(field_get:chat.ChangeStatusResponse.status)
  return status_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeStatusResponse::set_status(const ::std::string& value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.ChangeStatusResponse.status)
}
inline void ChangeStatusResponse::set_status(const char* value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.ChangeStatusResponse.status)
}
inline void ChangeStatusResponse::set_status(const char* value, size_t size) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.ChangeStatusResponse.status)
}
inline ::std::string* ChangeStatusResponse::mutable_status() {
  set_has_status();
  // @@protoc_insertion_point(field_mutable:chat.ChangeStatusResponse.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangeStatusResponse::release_status() {
  // @@protoc_insertion_point(field_release:chat.ChangeStatusResponse.status)
  clear_has_status();
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeStatusResponse::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    set_has_status();
  } else {
    clear_has_status();
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:chat.ChangeStatusResponse.status)
}

// -------------------------------------------------------------------

// BroadcastRequest

// required string message = 1;
inline bool BroadcastRequest::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadcastRequest::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadcastRequest::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadcastRequest::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& BroadcastRequest::message() const {
  // @@protoc_insertion_point(field_get:chat.BroadcastRequest.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BroadcastRequest::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.BroadcastRequest.message)
}
inline void BroadcastRequest::set_message(const char* value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.BroadcastRequest.message)
}
inline void BroadcastRequest::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.BroadcastRequest.message)
}
inline ::std::string* BroadcastRequest::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:chat.BroadcastRequest.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BroadcastRequest::release_message() {
  // @@protoc_insertion_point(field_release:chat.BroadcastRequest.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BroadcastRequest::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:chat.BroadcastRequest.message)
}

// -------------------------------------------------------------------

// BroadcastResponse

// required string messageStatus = 1;
inline bool BroadcastResponse::has_messagestatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadcastResponse::set_has_messagestatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadcastResponse::clear_has_messagestatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadcastResponse::clear_messagestatus() {
  messagestatus_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_messagestatus();
}
inline const ::std::string& BroadcastResponse::messagestatus() const {
  // @@protoc_insertion_point(field_get:chat.BroadcastResponse.messageStatus)
  return messagestatus_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BroadcastResponse::set_messagestatus(const ::std::string& value) {
  set_has_messagestatus();
  messagestatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.BroadcastResponse.messageStatus)
}
inline void BroadcastResponse::set_messagestatus(const char* value) {
  set_has_messagestatus();
  messagestatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.BroadcastResponse.messageStatus)
}
inline void BroadcastResponse::set_messagestatus(const char* value, size_t size) {
  set_has_messagestatus();
  messagestatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.BroadcastResponse.messageStatus)
}
inline ::std::string* BroadcastResponse::mutable_messagestatus() {
  set_has_messagestatus();
  // @@protoc_insertion_point(field_mutable:chat.BroadcastResponse.messageStatus)
  return messagestatus_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BroadcastResponse::release_messagestatus() {
  // @@protoc_insertion_point(field_release:chat.BroadcastResponse.messageStatus)
  clear_has_messagestatus();
  return messagestatus_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BroadcastResponse::set_allocated_messagestatus(::std::string* messagestatus) {
  if (messagestatus != NULL) {
    set_has_messagestatus();
  } else {
    clear_has_messagestatus();
  }
  messagestatus_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messagestatus);
  // @@protoc_insertion_point(field_set_allocated:chat.BroadcastResponse.messageStatus)
}

// -------------------------------------------------------------------

// BroadcastMessage

// required string message = 1;
inline bool BroadcastMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadcastMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadcastMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadcastMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& BroadcastMessage::message() const {
  // @@protoc_insertion_point(field_get:chat.BroadcastMessage.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BroadcastMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.BroadcastMessage.message)
}
inline void BroadcastMessage::set_message(const char* value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.BroadcastMessage.message)
}
inline void BroadcastMessage::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.BroadcastMessage.message)
}
inline ::std::string* BroadcastMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:chat.BroadcastMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BroadcastMessage::release_message() {
  // @@protoc_insertion_point(field_release:chat.BroadcastMessage.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BroadcastMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:chat.BroadcastMessage.message)
}

// required int32 userId = 2;
inline bool BroadcastMessage::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BroadcastMessage::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BroadcastMessage::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BroadcastMessage::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 BroadcastMessage::userid() const {
  // @@protoc_insertion_point(field_get:chat.BroadcastMessage.userId)
  return userid_;
}
inline void BroadcastMessage::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.BroadcastMessage.userId)
}

// -------------------------------------------------------------------

// DirectMessageRequest

// required string message = 1;
inline bool DirectMessageRequest::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectMessageRequest::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectMessageRequest::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectMessageRequest::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& DirectMessageRequest::message() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessageRequest.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectMessageRequest::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.DirectMessageRequest.message)
}
inline void DirectMessageRequest::set_message(const char* value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.DirectMessageRequest.message)
}
inline void DirectMessageRequest::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.DirectMessageRequest.message)
}
inline ::std::string* DirectMessageRequest::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:chat.DirectMessageRequest.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectMessageRequest::release_message() {
  // @@protoc_insertion_point(field_release:chat.DirectMessageRequest.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectMessageRequest::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:chat.DirectMessageRequest.message)
}

// optional int32 userId = 2;
inline bool DirectMessageRequest::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectMessageRequest::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectMessageRequest::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectMessageRequest::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 DirectMessageRequest::userid() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessageRequest.userId)
  return userid_;
}
inline void DirectMessageRequest::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.DirectMessageRequest.userId)
}

// optional string username = 3;
inline bool DirectMessageRequest::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DirectMessageRequest::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DirectMessageRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DirectMessageRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& DirectMessageRequest::username() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessageRequest.username)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectMessageRequest::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.DirectMessageRequest.username)
}
inline void DirectMessageRequest::set_username(const char* value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.DirectMessageRequest.username)
}
inline void DirectMessageRequest::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.DirectMessageRequest.username)
}
inline ::std::string* DirectMessageRequest::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:chat.DirectMessageRequest.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectMessageRequest::release_username() {
  // @@protoc_insertion_point(field_release:chat.DirectMessageRequest.username)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectMessageRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:chat.DirectMessageRequest.username)
}

// -------------------------------------------------------------------

// DirectMessageResponse

// required string messageStatus = 1;
inline bool DirectMessageResponse::has_messagestatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectMessageResponse::set_has_messagestatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectMessageResponse::clear_has_messagestatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectMessageResponse::clear_messagestatus() {
  messagestatus_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_messagestatus();
}
inline const ::std::string& DirectMessageResponse::messagestatus() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessageResponse.messageStatus)
  return messagestatus_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectMessageResponse::set_messagestatus(const ::std::string& value) {
  set_has_messagestatus();
  messagestatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.DirectMessageResponse.messageStatus)
}
inline void DirectMessageResponse::set_messagestatus(const char* value) {
  set_has_messagestatus();
  messagestatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.DirectMessageResponse.messageStatus)
}
inline void DirectMessageResponse::set_messagestatus(const char* value, size_t size) {
  set_has_messagestatus();
  messagestatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.DirectMessageResponse.messageStatus)
}
inline ::std::string* DirectMessageResponse::mutable_messagestatus() {
  set_has_messagestatus();
  // @@protoc_insertion_point(field_mutable:chat.DirectMessageResponse.messageStatus)
  return messagestatus_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectMessageResponse::release_messagestatus() {
  // @@protoc_insertion_point(field_release:chat.DirectMessageResponse.messageStatus)
  clear_has_messagestatus();
  return messagestatus_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectMessageResponse::set_allocated_messagestatus(::std::string* messagestatus) {
  if (messagestatus != NULL) {
    set_has_messagestatus();
  } else {
    clear_has_messagestatus();
  }
  messagestatus_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messagestatus);
  // @@protoc_insertion_point(field_set_allocated:chat.DirectMessageResponse.messageStatus)
}

// -------------------------------------------------------------------

// DirectMessage

// required string message = 1;
inline bool DirectMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& DirectMessage::message() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessage.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.DirectMessage.message)
}
inline void DirectMessage::set_message(const char* value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.DirectMessage.message)
}
inline void DirectMessage::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.DirectMessage.message)
}
inline ::std::string* DirectMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:chat.DirectMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectMessage::release_message() {
  // @@protoc_insertion_point(field_release:chat.DirectMessage.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:chat.DirectMessage.message)
}

// required int32 userId = 2;
inline bool DirectMessage::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectMessage::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectMessage::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectMessage::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 DirectMessage::userid() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessage.userId)
  return userid_;
}
inline void DirectMessage::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.DirectMessage.userId)
}

// -------------------------------------------------------------------

// ErrorResponse

// required string errorMessage = 1;
inline bool ErrorResponse::has_errormessage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorResponse::set_has_errormessage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrorResponse::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrorResponse::clear_errormessage() {
  errormessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errormessage();
}
inline const ::std::string& ErrorResponse::errormessage() const {
  // @@protoc_insertion_point(field_get:chat.ErrorResponse.errorMessage)
  return errormessage_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ErrorResponse::set_errormessage(const ::std::string& value) {
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chat.ErrorResponse.errorMessage)
}
inline void ErrorResponse::set_errormessage(const char* value) {
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chat.ErrorResponse.errorMessage)
}
inline void ErrorResponse::set_errormessage(const char* value, size_t size) {
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chat.ErrorResponse.errorMessage)
}
inline ::std::string* ErrorResponse::mutable_errormessage() {
  set_has_errormessage();
  // @@protoc_insertion_point(field_mutable:chat.ErrorResponse.errorMessage)
  return errormessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ErrorResponse::release_errormessage() {
  // @@protoc_insertion_point(field_release:chat.ErrorResponse.errorMessage)
  clear_has_errormessage();
  return errormessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ErrorResponse::set_allocated_errormessage(::std::string* errormessage) {
  if (errormessage != NULL) {
    set_has_errormessage();
  } else {
    clear_has_errormessage();
  }
  errormessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errormessage);
  // @@protoc_insertion_point(field_set_allocated:chat.ErrorResponse.errorMessage)
}

// -------------------------------------------------------------------

// ClientMessage

// required int32 option = 1;
inline bool ClientMessage::has_option() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage::set_has_option() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage::clear_has_option() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage::clear_option() {
  option_ = 0;
  clear_has_option();
}
inline ::google::protobuf::int32 ClientMessage::option() const {
  // @@protoc_insertion_point(field_get:chat.ClientMessage.option)
  return option_;
}
inline void ClientMessage::set_option(::google::protobuf::int32 value) {
  set_has_option();
  option_ = value;
  // @@protoc_insertion_point(field_set:chat.ClientMessage.option)
}

// optional int32 userId = 2;
inline bool ClientMessage::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 ClientMessage::userid() const {
  // @@protoc_insertion_point(field_get:chat.ClientMessage.userId)
  return userid_;
}
inline void ClientMessage::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:chat.ClientMessage.userId)
}

// optional .chat.MyInfoSynchronize synchronize = 3;
inline bool ClientMessage::has_synchronize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientMessage::set_has_synchronize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientMessage::clear_has_synchronize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientMessage::clear_synchronize() {
  if (synchronize_ != NULL) synchronize_->::chat::MyInfoSynchronize::Clear();
  clear_has_synchronize();
}
inline const ::chat::MyInfoSynchronize& ClientMessage::synchronize() const {
  // @@protoc_insertion_point(field_get:chat.ClientMessage.synchronize)
  return synchronize_ != NULL ? *synchronize_ : *default_instance_->synchronize_;
}
inline ::chat::MyInfoSynchronize* ClientMessage::mutable_synchronize() {
  set_has_synchronize();
  if (synchronize_ == NULL) {
    synchronize_ = new ::chat::MyInfoSynchronize;
  }
  // @@protoc_insertion_point(field_mutable:chat.ClientMessage.synchronize)
  return synchronize_;
}
inline ::chat::MyInfoSynchronize* ClientMessage::release_synchronize() {
  // @@protoc_insertion_point(field_release:chat.ClientMessage.synchronize)
  clear_has_synchronize();
  ::chat::MyInfoSynchronize* temp = synchronize_;
  synchronize_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_synchronize(::chat::MyInfoSynchronize* synchronize) {
  delete synchronize_;
  synchronize_ = synchronize;
  if (synchronize) {
    set_has_synchronize();
  } else {
    clear_has_synchronize();
  }
  // @@protoc_insertion_point(field_set_allocated:chat.ClientMessage.synchronize)
}

// optional .chat.connectedUserRequest connectedUsers = 4;
inline bool ClientMessage::has_connectedusers() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientMessage::set_has_connectedusers() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientMessage::clear_has_connectedusers() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientMessage::clear_connectedusers() {
  if (connectedusers_ != NULL) connectedusers_->::chat::connectedUserRequest::Clear();
  clear_has_connectedusers();
}
inline const ::chat::connectedUserRequest& ClientMessage::connectedusers() const {
  // @@protoc_insertion_point(field_get:chat.ClientMessage.connectedUsers)
  return connectedusers_ != NULL ? *connectedusers_ : *default_instance_->connectedusers_;
}
inline ::chat::connectedUserRequest* ClientMessage::mutable_connectedusers() {
  set_has_connectedusers();
  if (connectedusers_ == NULL) {
    connectedusers_ = new ::chat::connectedUserRequest;
  }
  // @@protoc_insertion_point(field_mutable:chat.ClientMessage.connectedUsers)
  return connectedusers_;
}
inline ::chat::connectedUserRequest* ClientMessage::release_connectedusers() {
  // @@protoc_insertion_point(field_release:chat.ClientMessage.connectedUsers)
  clear_has_connectedusers();
  ::chat::connectedUserRequest* temp = connectedusers_;
  connectedusers_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_connectedusers(::chat::connectedUserRequest* connectedusers) {
  delete connectedusers_;
  connectedusers_ = connectedusers;
  if (connectedusers) {
    set_has_connectedusers();
  } else {
    clear_has_connectedusers();
  }
  // @@protoc_insertion_point(field_set_allocated:chat.ClientMessage.connectedUsers)
}

// optional .chat.ChangeStatusRequest changeStatus = 5;
inline bool ClientMessage::has_changestatus() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientMessage::set_has_changestatus() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientMessage::clear_has_changestatus() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientMessage::clear_changestatus() {
  if (changestatus_ != NULL) changestatus_->::chat::ChangeStatusRequest::Clear();
  clear_has_changestatus();
}
inline const ::chat::ChangeStatusRequest& ClientMessage::changestatus() const {
  // @@protoc_insertion_point(field_get:chat.ClientMessage.changeStatus)
  return changestatus_ != NULL ? *changestatus_ : *default_instance_->changestatus_;
}
inline ::chat::ChangeStatusRequest* ClientMessage::mutable_changestatus() {
  set_has_changestatus();
  if (changestatus_ == NULL) {
    changestatus_ = new ::chat::ChangeStatusRequest;
  }
  // @@protoc_insertion_point(field_mutable:chat.ClientMessage.changeStatus)
  return changestatus_;
}
inline ::chat::ChangeStatusRequest* ClientMessage::release_changestatus() {
  // @@protoc_insertion_point(field_release:chat.ClientMessage.changeStatus)
  clear_has_changestatus();
  ::chat::ChangeStatusRequest* temp = changestatus_;
  changestatus_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_changestatus(::chat::ChangeStatusRequest* changestatus) {
  delete changestatus_;
  changestatus_ = changestatus;
  if (changestatus) {
    set_has_changestatus();
  } else {
    clear_has_changestatus();
  }
  // @@protoc_insertion_point(field_set_allocated:chat.ClientMessage.changeStatus)
}

// optional .chat.BroadcastRequest broadcast = 6;
inline bool ClientMessage::has_broadcast() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientMessage::set_has_broadcast() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientMessage::clear_has_broadcast() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientMessage::clear_broadcast() {
  if (broadcast_ != NULL) broadcast_->::chat::BroadcastRequest::Clear();
  clear_has_broadcast();
}
inline const ::chat::BroadcastRequest& ClientMessage::broadcast() const {
  // @@protoc_insertion_point(field_get:chat.ClientMessage.broadcast)
  return broadcast_ != NULL ? *broadcast_ : *default_instance_->broadcast_;
}
inline ::chat::BroadcastRequest* ClientMessage::mutable_broadcast() {
  set_has_broadcast();
  if (broadcast_ == NULL) {
    broadcast_ = new ::chat::BroadcastRequest;
  }
  // @@protoc_insertion_point(field_mutable:chat.ClientMessage.broadcast)
  return broadcast_;
}
inline ::chat::BroadcastRequest* ClientMessage::release_broadcast() {
  // @@protoc_insertion_point(field_release:chat.ClientMessage.broadcast)
  clear_has_broadcast();
  ::chat::BroadcastRequest* temp = broadcast_;
  broadcast_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_broadcast(::chat::BroadcastRequest* broadcast) {
  delete broadcast_;
  broadcast_ = broadcast;
  if (broadcast) {
    set_has_broadcast();
  } else {
    clear_has_broadcast();
  }
  // @@protoc_insertion_point(field_set_allocated:chat.ClientMessage.broadcast)
}

// optional .chat.DirectMessageRequest directMessage = 7;
inline bool ClientMessage::has_directmessage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientMessage::set_has_directmessage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientMessage::clear_has_directmessage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientMessage::clear_directmessage() {
  if (directmessage_ != NULL) directmessage_->::chat::DirectMessageRequest::Clear();
  clear_has_directmessage();
}
inline const ::chat::DirectMessageRequest& ClientMessage::directmessage() const {
  // @@protoc_insertion_point(field_get:chat.ClientMessage.directMessage)
  return directmessage_ != NULL ? *directmessage_ : *default_instance_->directmessage_;
}
inline ::chat::DirectMessageRequest* ClientMessage::mutable_directmessage() {
  set_has_directmessage();
  if (directmessage_ == NULL) {
    directmessage_ = new ::chat::DirectMessageRequest;
  }
  // @@protoc_insertion_point(field_mutable:chat.ClientMessage.directMessage)
  return directmessage_;
}
inline ::chat::DirectMessageRequest* ClientMessage::release_directmessage() {
  // @@protoc_insertion_point(field_release:chat.ClientMessage.directMessage)
  clear_has_directmessage();
  ::chat::DirectMessageRequest* temp = directmessage_;
  directmessage_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_directmessage(::chat::DirectMessageRequest* directmessage) {
  delete directmessage_;
  directmessage_ = directmessage;
  if (directmessage) {
    set_has_directmessage();
  } else {
    clear_has_directmessage();
  }
  // @@protoc_insertion_point(field_set_allocated:chat.ClientMessage.directMessage)
}

// optional .chat.MyInfoAcknowledge acknowledge = 8;
inline bool ClientMessage::has_acknowledge() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientMessage::set_has_acknowledge() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientMessage::clear_has_acknowledge() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientMessage::clear_acknowledge() {
  if (acknowledge_ != NULL) acknowledge_->::chat::MyInfoAcknowledge::Clear();
  clear_has_acknowledge();
}
inline const ::chat::MyInfoAcknowledge& ClientMessage::acknowledge() const {
  // @@protoc_insertion_point(field_get:chat.ClientMessage.acknowledge)
  return acknowledge_ != NULL ? *acknowledge_ : *default_instance_->acknowledge_;
}
inline ::chat::MyInfoAcknowledge* ClientMessage::mutable_acknowledge() {
  set_has_acknowledge();
  if (acknowledge_ == NULL) {
    acknowledge_ = new ::chat::MyInfoAcknowledge;
  }
  // @@protoc_insertion_point(field_mutable:chat.ClientMessage.acknowledge)
  return acknowledge_;
}
inline ::chat::MyInfoAcknowledge* ClientMessage::release_acknowledge() {
  // @@protoc_insertion_point(field_release:chat.ClientMessage.acknowledge)
  clear_has_acknowledge();
  ::chat::MyInfoAcknowledge* temp = acknowledge_;
  acknowledge_ = NULL;
  return temp;
}
inline void ClientMessage::set_allocated_acknowledge(::chat::MyInfoAcknowledge* acknowledge) {
  delete acknowledge_;
  acknowledge_ = acknowledge;
  if (acknowledge) {
    set_has_acknowledge();
  } else {
    clear_has_acknowledge();
  }
  // @@protoc_insertion_point(field_set_allocated:chat.ClientMessage.acknowledge)
}

// -------------------------------------------------------------------

// ServerMessage

// required int32 option = 1;
inline bool ServerMessage::has_option() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerMessage::set_has_option() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerMessage::clear_has_option() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerMessage::clear_option() {
  option_ = 0;
  clear_has_option();
}
inline ::google::protobuf::int32 ServerMessage::option() const {
  // @@protoc_insertion_point(field_get:chat.ServerMessage.option)
  return option_;
}
inline void ServerMessage::set_option(::google::protobuf::int32 value) {
  set_has_option();
  option_ = value;
  // @@protoc_insertion_point(field_set:chat.ServerMessage.option)
}

// optional .chat.BroadcastMessage broadcast = 2;
inline bool ServerMessage::has_broadcast() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerMessage::set_has_broadcast() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerMessage::clear_has_broadcast() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerMessage::clear_broadcast() {
  if (broadcast_ != NULL) broadcast_->::chat::BroadcastMessage::Clear();
  clear_has_broadcast();
}
inline const ::chat::BroadcastMessage& ServerMessage::broadcast() const {
  // @@protoc_insertion_point(field_get:chat.ServerMessage.broadcast)
  return broadcast_ != NULL ? *broadcast_ : *default_instance_->broadcast_;
}
inline ::chat::BroadcastMessage* ServerMessage::mutable_broadcast() {
  set_has_broadcast();
  if (broadcast_ == NULL) {
    broadcast_ = new ::chat::BroadcastMessage;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerMessage.broadcast)
  return broadcast_;
}
inline ::chat::BroadcastMessage* ServerMessage::release_broadcast() {
  // @@protoc_insertion_point(field_release:chat.ServerMessage.broadcast)
  clear_has_broadcast();
  ::chat::BroadcastMessage* temp = broadcast_;
  broadcast_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_broadcast(::chat::BroadcastMessage* broadcast) {
  delete broadcast_;
  broadcast_ = broadcast;
  if (broadcast) {
    set_has_broadcast();
  } else {
    clear_has_broadcast();
  }
  // @@protoc_insertion_point(field_set_allocated:chat.ServerMessage.broadcast)
}

// optional .chat.DirectMessage message = 3;
inline bool ServerMessage::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerMessage::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerMessage::clear_message() {
  if (message_ != NULL) message_->::chat::DirectMessage::Clear();
  clear_has_message();
}
inline const ::chat::DirectMessage& ServerMessage::message() const {
  // @@protoc_insertion_point(field_get:chat.ServerMessage.message)
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::chat::DirectMessage* ServerMessage::mutable_message() {
  set_has_message();
  if (message_ == NULL) {
    message_ = new ::chat::DirectMessage;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerMessage.message)
  return message_;
}
inline ::chat::DirectMessage* ServerMessage::release_message() {
  // @@protoc_insertion_point(field_release:chat.ServerMessage.message)
  clear_has_message();
  ::chat::DirectMessage* temp = message_;
  message_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_message(::chat::DirectMessage* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
  // @@protoc_insertion_point(field_set_allocated:chat.ServerMessage.message)
}

// optional .chat.ErrorResponse error = 4;
inline bool ServerMessage::has_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerMessage::set_has_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerMessage::clear_has_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerMessage::clear_error() {
  if (error_ != NULL) error_->::chat::ErrorResponse::Clear();
  clear_has_error();
}
inline const ::chat::ErrorResponse& ServerMessage::error() const {
  // @@protoc_insertion_point(field_get:chat.ServerMessage.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::chat::ErrorResponse* ServerMessage::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    error_ = new ::chat::ErrorResponse;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerMessage.error)
  return error_;
}
inline ::chat::ErrorResponse* ServerMessage::release_error() {
  // @@protoc_insertion_point(field_release:chat.ServerMessage.error)
  clear_has_error();
  ::chat::ErrorResponse* temp = error_;
  error_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_error(::chat::ErrorResponse* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:chat.ServerMessage.error)
}

// optional .chat.MyInfoResponse myInfoResponse = 5;
inline bool ServerMessage::has_myinforesponse() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerMessage::set_has_myinforesponse() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerMessage::clear_has_myinforesponse() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerMessage::clear_myinforesponse() {
  if (myinforesponse_ != NULL) myinforesponse_->::chat::MyInfoResponse::Clear();
  clear_has_myinforesponse();
}
inline const ::chat::MyInfoResponse& ServerMessage::myinforesponse() const {
  // @@protoc_insertion_point(field_get:chat.ServerMessage.myInfoResponse)
  return myinforesponse_ != NULL ? *myinforesponse_ : *default_instance_->myinforesponse_;
}
inline ::chat::MyInfoResponse* ServerMessage::mutable_myinforesponse() {
  set_has_myinforesponse();
  if (myinforesponse_ == NULL) {
    myinforesponse_ = new ::chat::MyInfoResponse;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerMessage.myInfoResponse)
  return myinforesponse_;
}
inline ::chat::MyInfoResponse* ServerMessage::release_myinforesponse() {
  // @@protoc_insertion_point(field_release:chat.ServerMessage.myInfoResponse)
  clear_has_myinforesponse();
  ::chat::MyInfoResponse* temp = myinforesponse_;
  myinforesponse_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_myinforesponse(::chat::MyInfoResponse* myinforesponse) {
  delete myinforesponse_;
  myinforesponse_ = myinforesponse;
  if (myinforesponse) {
    set_has_myinforesponse();
  } else {
    clear_has_myinforesponse();
  }
  // @@protoc_insertion_point(field_set_allocated:chat.ServerMessage.myInfoResponse)
}

// optional .chat.ConnectedUserResponse connectedUserResponse = 6;
inline bool ServerMessage::has_connecteduserresponse() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerMessage::set_has_connecteduserresponse() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerMessage::clear_has_connecteduserresponse() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerMessage::clear_connecteduserresponse() {
  if (connecteduserresponse_ != NULL) connecteduserresponse_->::chat::ConnectedUserResponse::Clear();
  clear_has_connecteduserresponse();
}
inline const ::chat::ConnectedUserResponse& ServerMessage::connecteduserresponse() const {
  // @@protoc_insertion_point(field_get:chat.ServerMessage.connectedUserResponse)
  return connecteduserresponse_ != NULL ? *connecteduserresponse_ : *default_instance_->connecteduserresponse_;
}
inline ::chat::ConnectedUserResponse* ServerMessage::mutable_connecteduserresponse() {
  set_has_connecteduserresponse();
  if (connecteduserresponse_ == NULL) {
    connecteduserresponse_ = new ::chat::ConnectedUserResponse;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerMessage.connectedUserResponse)
  return connecteduserresponse_;
}
inline ::chat::ConnectedUserResponse* ServerMessage::release_connecteduserresponse() {
  // @@protoc_insertion_point(field_release:chat.ServerMessage.connectedUserResponse)
  clear_has_connecteduserresponse();
  ::chat::ConnectedUserResponse* temp = connecteduserresponse_;
  connecteduserresponse_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_connecteduserresponse(::chat::ConnectedUserResponse* connecteduserresponse) {
  delete connecteduserresponse_;
  connecteduserresponse_ = connecteduserresponse;
  if (connecteduserresponse) {
    set_has_connecteduserresponse();
  } else {
    clear_has_connecteduserresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:chat.ServerMessage.connectedUserResponse)
}

// optional .chat.ChangeStatusResponse changeStatusResponse = 7;
inline bool ServerMessage::has_changestatusresponse() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServerMessage::set_has_changestatusresponse() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ServerMessage::clear_has_changestatusresponse() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ServerMessage::clear_changestatusresponse() {
  if (changestatusresponse_ != NULL) changestatusresponse_->::chat::ChangeStatusResponse::Clear();
  clear_has_changestatusresponse();
}
inline const ::chat::ChangeStatusResponse& ServerMessage::changestatusresponse() const {
  // @@protoc_insertion_point(field_get:chat.ServerMessage.changeStatusResponse)
  return changestatusresponse_ != NULL ? *changestatusresponse_ : *default_instance_->changestatusresponse_;
}
inline ::chat::ChangeStatusResponse* ServerMessage::mutable_changestatusresponse() {
  set_has_changestatusresponse();
  if (changestatusresponse_ == NULL) {
    changestatusresponse_ = new ::chat::ChangeStatusResponse;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerMessage.changeStatusResponse)
  return changestatusresponse_;
}
inline ::chat::ChangeStatusResponse* ServerMessage::release_changestatusresponse() {
  // @@protoc_insertion_point(field_release:chat.ServerMessage.changeStatusResponse)
  clear_has_changestatusresponse();
  ::chat::ChangeStatusResponse* temp = changestatusresponse_;
  changestatusresponse_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_changestatusresponse(::chat::ChangeStatusResponse* changestatusresponse) {
  delete changestatusresponse_;
  changestatusresponse_ = changestatusresponse;
  if (changestatusresponse) {
    set_has_changestatusresponse();
  } else {
    clear_has_changestatusresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:chat.ServerMessage.changeStatusResponse)
}

// optional .chat.BroadcastResponse broadcastResponse = 8;
inline bool ServerMessage::has_broadcastresponse() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ServerMessage::set_has_broadcastresponse() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ServerMessage::clear_has_broadcastresponse() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ServerMessage::clear_broadcastresponse() {
  if (broadcastresponse_ != NULL) broadcastresponse_->::chat::BroadcastResponse::Clear();
  clear_has_broadcastresponse();
}
inline const ::chat::BroadcastResponse& ServerMessage::broadcastresponse() const {
  // @@protoc_insertion_point(field_get:chat.ServerMessage.broadcastResponse)
  return broadcastresponse_ != NULL ? *broadcastresponse_ : *default_instance_->broadcastresponse_;
}
inline ::chat::BroadcastResponse* ServerMessage::mutable_broadcastresponse() {
  set_has_broadcastresponse();
  if (broadcastresponse_ == NULL) {
    broadcastresponse_ = new ::chat::BroadcastResponse;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerMessage.broadcastResponse)
  return broadcastresponse_;
}
inline ::chat::BroadcastResponse* ServerMessage::release_broadcastresponse() {
  // @@protoc_insertion_point(field_release:chat.ServerMessage.broadcastResponse)
  clear_has_broadcastresponse();
  ::chat::BroadcastResponse* temp = broadcastresponse_;
  broadcastresponse_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_broadcastresponse(::chat::BroadcastResponse* broadcastresponse) {
  delete broadcastresponse_;
  broadcastresponse_ = broadcastresponse;
  if (broadcastresponse) {
    set_has_broadcastresponse();
  } else {
    clear_has_broadcastresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:chat.ServerMessage.broadcastResponse)
}

// optional .chat.DirectMessageResponse directMessageResponse = 9;
inline bool ServerMessage::has_directmessageresponse() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ServerMessage::set_has_directmessageresponse() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ServerMessage::clear_has_directmessageresponse() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ServerMessage::clear_directmessageresponse() {
  if (directmessageresponse_ != NULL) directmessageresponse_->::chat::DirectMessageResponse::Clear();
  clear_has_directmessageresponse();
}
inline const ::chat::DirectMessageResponse& ServerMessage::directmessageresponse() const {
  // @@protoc_insertion_point(field_get:chat.ServerMessage.directMessageResponse)
  return directmessageresponse_ != NULL ? *directmessageresponse_ : *default_instance_->directmessageresponse_;
}
inline ::chat::DirectMessageResponse* ServerMessage::mutable_directmessageresponse() {
  set_has_directmessageresponse();
  if (directmessageresponse_ == NULL) {
    directmessageresponse_ = new ::chat::DirectMessageResponse;
  }
  // @@protoc_insertion_point(field_mutable:chat.ServerMessage.directMessageResponse)
  return directmessageresponse_;
}
inline ::chat::DirectMessageResponse* ServerMessage::release_directmessageresponse() {
  // @@protoc_insertion_point(field_release:chat.ServerMessage.directMessageResponse)
  clear_has_directmessageresponse();
  ::chat::DirectMessageResponse* temp = directmessageresponse_;
  directmessageresponse_ = NULL;
  return temp;
}
inline void ServerMessage::set_allocated_directmessageresponse(::chat::DirectMessageResponse* directmessageresponse) {
  delete directmessageresponse_;
  directmessageresponse_ = directmessageresponse;
  if (directmessageresponse) {
    set_has_directmessageresponse();
  } else {
    clear_has_directmessageresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:chat.ServerMessage.directMessageResponse)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chat

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mensaje_2eproto__INCLUDED
